using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Textexemplu2.Kociemba
{
    class CubieCube
    {
        // 16 symmetries generated by S_F2, S_U4 and S_LR2
        internal static CubieCube[] CubeSym = new CubieCube[16];

        // 18 move cubes
        internal static CubieCube[] moveCube = new CubieCube[18];

        internal static long[] moveCubeSym = new long[18];
        internal static int[] firstMoveSym = new int[48];

        internal static int[] preMove = new int[] { -1, Util.Rx1, Util.Rx3, Util.Fx1, Util.Fx3, Util.Lx1, Util.Lx3, Util.Bx1, Util.Bx3 };

        internal static int[,] SymMult = new int[16, 16];
        internal static int[,] SymMultInv = new int[16, 16];
        internal static int[,] SymMove = new int[16, 18];
        internal static int[] Sym8Move = new int[8 * 18];
        internal static int[,] SymMoveUD = new int[16, 18];

        // ClassIndexToRepresentantArrays

        internal static char[] FlipS2R = new char[336];
        internal static char[] TwistS2R = new char[324];
        internal static char[] EPermS2R = new char[2768];
        internal static sbyte[] Perm2Comb = new sbyte[2768];
        internal static char[] PermInvEdgeSym = new char[2768];

        internal static int SYM_E2C_MAGIC = 0x00DDDD00;
        internal static int ESym2CSym(int idx)
        {
            return idx ^ (SYM_E2C_MAGIC >> ((idx & 0xf) << 1) & 3);
        }

        internal static char[] MtoEPerm = new char[40320];

        // Raw-Coordnate to Sym-Coordnate, only for speeding up initializaion.

        internal static char[] FlipR2S; // = new char[2048];   edge orientation
        internal static char[] TwistR2S; // = new char[2187];    corner orientation
        internal static char[] EPermR2S; // = new char[40320];    corner permutation
        internal static char[] FlipS2RF = Search.USE_TWIST_FLIP_PRUN ? new char[336 * 8] : null;

        /// 
        internal static char[] SymStateTwist = new char[324];
        internal static char[] SymStateFlip = new char[336];
        internal static char[] SymStatePerm = new char[2768];

        internal static CubieCube urf1 = new CubieCube(2531, 1373, 67026819, 1367);
        internal static CubieCube urf2 = new CubieCube(2089, 1906, 322752913, 2040);
        internal static sbyte[,] urfMove = new sbyte[,]
        {
        {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17},
        {6, 7, 8, 0, 1, 2, 3, 4, 5, 15, 16, 17, 9, 10, 11, 12, 13, 14},
        {3, 4, 5, 6, 7, 8, 0, 1, 2, 12, 13, 14, 15, 16, 17, 9, 10, 11},
        {2, 1, 0, 5, 4, 3, 8, 7, 6, 11, 10, 9, 14, 13, 12, 17, 16, 15},
        {8, 7, 6, 2, 1, 0, 5, 4, 3, 17, 16, 15, 11, 10, 9, 14, 13, 12},
        {5, 4, 3, 8, 7, 6, 2, 1, 0, 14, 13, 12, 17, 16, 15, 11, 10, 9}
        };

        internal sbyte[] ca = { 0, 1, 2, 3, 4, 5, 6, 7 };
        internal sbyte[] ea = { 0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22 };
        internal CubieCube temps = null;

        internal CubieCube()
        {

        }

        internal CubieCube(int cperm, int twist, int eperm, int flip)
        {
            SetCPerm(cperm);
            SetTwist(twist);
            Util.SetNPerm(ea, eperm, 12, true);
            SetFlip(flip);
        }

        internal CubieCube(CubieCube c)
        {
            Copy(c);
        }

        internal virtual void Copy(CubieCube c)
        {
            for (int i = 0; i < 8; i++)
            {
                ca[i] = c.ca[i];
            }
            for (int i = 0; i < 12; i++)
            {
                ea[i] = c.ea[i];
            }
        }

        internal virtual void InvCubieCube()
        {
            if (temps == null)
            {
                temps = new CubieCube();
            }
            for (sbyte edge = 0; edge < 12; edge++)
            {
                temps.ea[ea[edge] >> 1] = Convert.ToSByte(edge << 1 | ea[edge] & 1);
            }
            for (sbyte corn = 0; corn < 8; corn++)
            {
                temps.ca[ca[corn] & 0x7] = Convert.ToSByte(corn | 0x20 >> (ca[corn] >> 3) & 0x18);
            }
            Copy(temps);
        }

        // prod = a * b, Corner Only.

        internal static void CornMult(CubieCube a, CubieCube b, CubieCube prod)
        {
            for (int corn = 0; corn < 8; corn++)
            {
                int oriA = a.ca[b.ca[corn] & 7] >> 3;
                int oriB = b.ca[corn] >> 3;
                int ori = oriA + ((oriA < 3) ? oriB : 6 - oriB);
                ori = ori % 3 + ((oriA < 3) == (oriB < 3) ? 0 : 3);
                prod.ca[corn] = (sbyte)(a.ca[b.ca[corn] & 7] & 7 | ori << 3);
            }
        }

        // prod = a * b, Edge Only.

        internal static void EdgeMult(CubieCube a, CubieCube b, CubieCube prod)
        {
            for (int ed = 0; ed < 12; ed++)
            {
                prod.ea[ed] = (sbyte)(a.ea[b.ea[ed] >> 1] ^ (b.ea[ed] & 1));
                // Console.WriteLine(ed + "+++++++++++++" + prod.ea[ed]);
            }
        }

        //  b = S_idx^-1 * a * S_idx, Corner Only.

        internal static void CornConjugate(CubieCube a, int idx, CubieCube b)
        {
            CubieCube sinv = CubeSym[SymMultInv[0, idx]];
            CubieCube s = CubeSym[idx];
            for (int corn = 0; corn < 8; corn++)
            {
                int oriA = sinv.ca[a.ca[s.ca[corn] & 7] & 7] >> 3;
                int oriB = a.ca[s.ca[corn] & 7] >> 3;
                int ori = (oriA < 3) ? oriB : (3 - oriB) % 3;
                b.ca[corn] = (sbyte)(sinv.ca[a.ca[s.ca[corn] & 7] & 7] & 7 | ori << 3);
            }
        }

        // b = S_idx^-1 * a * S_idx, Edge Only.

        internal static void EdgeConjugate(CubieCube a, int idx, CubieCube b)
        {
            CubieCube sinv = CubeSym[SymMultInv[0, idx]];
            CubieCube s = CubeSym[idx];
            for (int ed = 0; ed < 12; ed++)
            {
                b.ea[ed] = (sbyte)(sinv.ea[a.ea[s.ea[ed] >> 1] >> 1] ^ (a.ea[s.ea[ed] >> 1] & 1) ^ (s.ea[ed] & 1));
            }
        }

        internal static int GetPermSymInv(int idx, int sym, bool isCorner)
        {
            int idxi = PermInvEdgeSym[idx];
            if (isCorner)
            {
                idxi = ESym2CSym(idxi);
            }
            return idxi & 0xfff0 | SymMult[idxi & 0xf, sym];
        }

        // this = S_urf^-1 * this * S_urf.

        internal virtual void URFConjugate()
        {
            if (temps == null)
            {
                temps = new CubieCube();
            }
            CornMult(urf2, this, temps);
            CornMult(temps, urf1, this);
            EdgeMult(urf2, this, temps);
            EdgeMult(temps, urf1, this);
        }

        // ********************************************* Get and set coordinates *********************************************
        // XSym : Symmetry Coordnate of X. MUST be called after initialization of ClassIndexToRepresentantArrays.

        // ++++++++++++++++++++ Phase 1 Coordnates ++++++++++++++++++++
        // Flip : Orientation of 12 Edges. Raw[0, 2048) Sym[0, 336 * 8)
        // Twist : Orientation of 8 Corners. Raw[0, 2187) Sym[0, 324 * 8)
        // UDSlice : Positions of the 4 UDSlice edges, the order is ignored.

        internal virtual int GetFlip()
        {
            int idx = 0;
            for (int i = 0; i < 11; i++)
            {
                idx = idx << 1 | ea[i] & 1;
            }
            return idx;
        }

        internal virtual void SetFlip(int idx)
        {
            int parity = 0, val;
            for (int i = 10; i >= 0; i--, idx >>= 1)
            {
                parity ^= (val = idx & 1);
                ea[i] = (sbyte)(ea[i] & 0xfe | val);
            }
            ea[11] = (sbyte)(ea[11] & 0xfe | parity);
        }


        internal virtual int GetFlipSym()
        {
            if (FlipR2S != null)
            {
                return FlipR2S[GetFlip()];
            }
            if (temps == null)
            {
                temps = new CubieCube();
            }
            for (int k = 0; k < 16; k += 2)
            {
                EdgeConjugate(this, SymMultInv[0, k], temps);
                int idx = Array.BinarySearch(FlipS2R, (char)temps.GetFlip());
                if (idx >= 0)
                {
                    return idx << 3 | k >> 1;
                }
            }
            Debug.Assert(false);
            return 0;
        }

        internal virtual int GetTwist()
        {
            int idx = 0;
            for (int i = 0; i < 7; i++)
            {
                idx += (idx << 1) + (ca[i] >> 3);
            }
            return idx;
        }

        internal virtual void SetTwist(int idx)
        {
            int twst = 15, val;
            for (int i = 6; i >= 0; i--, idx /= 3)
            {
                twst -= (val = idx % 3);
                ca[i] = (sbyte)(ca[i] & 0x7 | val << 3);
            }
            ca[7] = (sbyte)(ca[7] & 0x7 | (twst % 3) << 3);

        }

        internal virtual int GetTwistSym()
        {
            if (TwistR2S != null)
            {
                return TwistR2S[GetTwist()];
            }
            if (temps == null)
            {
                temps = new CubieCube();
            }
            for (int k = 0; k < 16; k += 2)
            {
                CornConjugate(this, SymMultInv[0, k], temps);
                int idx = Array.BinarySearch(TwistS2R, (char)temps.GetTwist());
                if (idx >= 0)
                {
                    return idx << 3 | k >> 1;
                }
            }
            Debug.Assert(false);
            return 0;
        }

        internal virtual int GetUDSlice()
        {
            return Util.GetComb(ea, 8, true);
        }

        internal virtual void SetUDSlice(int idx)
        {
            Util.SetComb(ea, idx, 8, true);
        }

        internal virtual int GetU4Comb()
        {
            return Util.GetComb(ea, 0, true);
        }

        internal virtual int GetD4Comb()
        {
            return Util.GetComb(ea, 4, true);
        }

        // ++++++++++++++++++++ Phase 2 Coordnates ++++++++++++++++++++
        // EPerm : Permutations of 8 UD Edges. Raw[0, 40320) Sym[0, 2187 * 16)
        // Cperm : Permutations of 8 Corners. Raw[0, 40320) Sym[0, 2187 * 16)
        // MPerm : Permutations of 4 UDSlice Edges. [0, 24)

        internal virtual int GetCPerm()
        {
            return Util.GetNPerm(ca, 8, false);
        }

        internal virtual void SetCPerm(int idx)
        {
            Util.SetNPerm(ca, idx, 8, false);
        }

        internal virtual int GetCPermSym()
        {
            if (EPermR2S != null)
            {
                return ESym2CSym(EPermR2S[GetCPerm()]);
            }
            if (temps == null)
            {
                temps = new CubieCube();
            }
            for (int k = 0; k < 16; k++)
            {
                CornConjugate(this, SymMultInv[0, k], temps);
                int idx = Array.BinarySearch(EPermS2R, (char)temps.GetCPerm());
                if (idx >= 0)
                {
                    return idx << 4 | k;
                }
            }
            Debug.Assert(false);
            return 0;
        }

        internal virtual int GetEPerm()
        {
            return Util.GetNPerm(ea, 8, true);
        }

        internal virtual void SetEPerm(int idx)
        {
            Util.SetNPerm(ea, idx, 8, true);
        }

        internal virtual int getEPermSym()
        {
            if (EPermR2S != null)
            {
                return EPermR2S[GetEPerm()];
            }
            if (temps == null)
            {
                temps = new CubieCube();
            }
            for (int k = 0; k < 16; k++)
            {
                EdgeConjugate(this, SymMultInv[0, k], temps);
                int idx = Array.BinarySearch(EPermS2R, (char)temps.GetEPerm());
                if (idx >= 0)
                {
                    return idx << 4 | k;
                }
            }
            return 0;
        }

        internal virtual int GetMPerm()
        {
            return Util.GetComb(ea, 8, true) >> 9;
        }

        internal virtual void SetMPerm(int idx)
        {
            Util.SetComb(ea, idx << 9, 8, true);
        }

        internal virtual int GetCComb()
        {
            return 69 - (Util.GetComb(ca, 0, false) & 0x1ff);
        }

        internal virtual void SetCComb(int idx)
        {
            Util.SetComb(ca, 69 - idx, 0, false);
        }

        /// <summary>
        /// Check a cubiecube for solvability. Return the error code.
        /// 0: Cube is solvable
        /// -2: Not all 12 edges exist exactly once
        /// -3: Flip error: One edge has to be flipped
        /// -4: Not all corners exist exactly once
        /// -5: Twist error: One corner has to be twisted
        /// -6: Parity error: Two corners or two edges have to be exchanged
        /// </summary>

        internal virtual int Verify()
        {
            int sum = 0;
            int edgeMask = 0;
            for (int e = 0; e < 12; e++)
            {
                edgeMask |= 1 << (ea[e] >> 1);
                sum ^= ea[e] & 1;
            }
            if (edgeMask != 0xfff)
            {
                return -2; // missing edges
            }
            if (sum != 0)
            {
                return -3;
            }
            int cornMask = 0;
            sum = 0;
            for (int c = 0; c < 8; c++)
            {
                cornMask |= 1 << (ca[c] & 7);
                sum += ca[c] >> 3;
            }
            if (cornMask != 0xff)
            {
                return -4; // missing corners
            }
            if (sum % 3 != 0)
            {
                return -5; // twisted corner
            }
            if ((Util.GetNParity(Util.GetNPerm(ea, 12, true), 12) ^ Util.GetNParity(GetCPerm(), 8)) != 0)
            {
                return -6; // parity error
            }
            return 0; // cube ok
        }

        internal virtual long SelfSymmetry()
        {
            CubieCube c = new CubieCube(this);
            CubieCube d = new CubieCube();
            long sym = 0L;
            for (int i = 0; i < 96; i++)
            {
                CornConjugate(c, SymMultInv[0, i % 16], d);
                if (d.ca.SequenceEqual(ca))
                {
                    EdgeConjugate(c, SymMultInv[0, i % 16], d);
                    if (d.ea.SequenceEqual(ea))
                    {
                        sym |= 1L << Math.Min(i, 48);
                    }
                }
                if (i % 16 == 15)
                {
                    c.URFConjugate();
                }
                if (i % 48 == 47)
                {
                    c.InvCubieCube();
                }
            }
            return sym;
        }

        // Initializing functions

        internal static void InitMove()
        {
            moveCube[0] = new CubieCube(15120, 0, 119750400, 0);
            moveCube[3] = new CubieCube(21021, 1494, 323403417, 0);
            moveCube[6] = new CubieCube(8064, 1236, 29441808, 550);
            moveCube[9] = new CubieCube(9, 0, 5880, 0);
            moveCube[12] = new CubieCube(1230, 412, 2949660, 0);
            moveCube[15] = new CubieCube(224, 137, 328552, 137);
            for (int a = 0; a < 18; a += 3)
            {
                for (int p = 0; p < 2; p++)
                {
                    moveCube[a + p + 1] = new CubieCube();
                    EdgeMult(moveCube[a + p], moveCube[a], moveCube[a + p + 1]);
                    CornMult(moveCube[a + p], moveCube[a], moveCube[a + p + 1]);
                }
            }
        }

        public override string ToString()
        {
            StringBuilder sb = new StringBuilder();
            for (int i = 0; i < 8; i++)
            {
                sb.Append("|" + (ca[i] & 7) + " " + (ca[i] >> 3));
            }
            sb.Append("\n");
            for (int i = 0; i < 12; i++)
            {
                sb.Append("|" + (ea[i] >> 1) + " " + (ea[i] & 1));
            }
            return sb.ToString();
        }

        internal static void InitSym()
        {
            CubieCube c = new CubieCube();
            CubieCube d = new CubieCube();
            CubieCube t;

            CubieCube f2 = new CubieCube(28783, 0, 259268407, 0);
            CubieCube u4 = new CubieCube(15138, 0, 119765538, 7);
            CubieCube lr2 = new CubieCube(5167, 0, 83473207, 0);
            for (int i = 0; i < 8; i++)
            {
                lr2.ca[i] |= 3 << 3;
            }

            for (int i = 0; i < 16; i++)
            {
                CubeSym[i] = new CubieCube(c);
                CornMult(c, u4, d);
                EdgeMult(c, u4, d);
                t = d;
                d = c;
                c = t;
                if (i % 4 == 3)
                {
                    CornMult(c, lr2, d);
                    EdgeMult(c, lr2, d);
                    t = d;
                    d = c;
                    c = t;
                }
                if (i % 8 == 7)
                {
                    CornMult(c, f2, d);
                    EdgeMult(c, f2, d);
                    t = d;
                    d = c;
                    c = t;
                }
            }
            for (int i = 0; i < 16; i++)
            {
                for (int j = 0; j < 16; j++)
                {
                    CornMult(CubeSym[i], CubeSym[j], c);
                    for (int k = 0; k < 16; k++)
                    {
                        if (CubeSym[k].ca.SequenceEqual(c.ca))
                        {
                            SymMult[i, j] = k; // SymMult[i][j] = (k ^ i ^ j ^ (0x14ab4 >> j & i << 1 & 2)));
                            SymMultInv[k, j] = i; // i * j = k => k * j^-1 = i
                                                  // Console.WriteLine("["+k+","+j+"]++++++" + SymMultInv[k, j]);
                            break;
                        }
                    }
                }
            }
            for (int j = 0; j < 18; j++)
            {
                for (int s = 0; s < 16; s++)
                {
                    CornConjugate(moveCube[j], SymMultInv[0, s], c);
                    for (int m = 0; m < 18; m++)
                    {
                        if (moveCube[m].ca.SequenceEqual(c.ca))
                        {
                            SymMove[s, j] = m;
                            SymMoveUD[s, Util.std2ud[j]] = Util.std2ud[m];
                            //   Console.WriteLine("[" + s + "," + Util.std2ud[j] + "]++++++" + SymMoveUD[s, Util.std2ud[j]]);
                            break;
                        }
                    }
                    if (s % 2 == 0)
                    {
                        Sym8Move[j << 3 | s >> 1] = SymMove[s, j];
                    }
                }
            }

            for (int i = 0; i < 18; i++)
            {
                moveCubeSym[i] = moveCube[i].SelfSymmetry();
                int j = i;
                for (int s = 0; s < 48; s++)
                {
                    if (SymMove[s % 16, j] < i)
                    {
                        firstMoveSym[s] |= 1 << i;
                        //Console.WriteLine("[" + s + "]++++++" + firstMoveSym[s]);
                    }
                    if (s % 16 == 15)
                    {
                        j = urfMove[2, j];
                    }
                }
            }
        }

        internal static int InitSym2Raw(int N_RAW, char[] Sym2Raw, char[] Raw2Sym, char[] SymState, int coord)
        {
            CubieCube c = new CubieCube();
            CubieCube d = new CubieCube();
            int count = 0, idx = 0;
            int sym_inc = coord >= 2 ? 1 : 2;
            bool isEdge = coord != 1;

            for (int i = 0; i < N_RAW; i++)
            {
                if (Raw2Sym[i] != 0)
                {
                    continue;
                }
                switch (coord)
                {
                    case 0:
                        c.SetFlip(i);
                        break;
                    case 1:
                        c.SetTwist(i);
                        break;
                    case 2:
                        c.SetEPerm(i);
                        break;
                }
                for (int s = 0; s < 16; s += sym_inc)
                {
                    if (isEdge)
                    {
                        EdgeConjugate(c, s, d);
                    }
                    else
                    {
                        CornConjugate(c, s, d);
                    }
                    switch (coord)
                    {
                        case 0:
                            idx = d.GetFlip();
                            if (Search.USE_TWIST_FLIP_PRUN)
                            {
                                FlipS2RF[count << 3 | s >> 1] = (char)idx;
                            }
                            break;
                        case 1:
                            idx = d.GetTwist();
                            break;
                        case 2:
                            idx = d.GetEPerm();
                            int a = d.GetU4Comb();
                            int m = 494 - (a & 0x1ff) + (a >> 9) * 70 + (d.GetD4Comb() >> 9) * 1680;
                            MtoEPerm[m] = (char)(count << 4 | s);
                            if (s == 0)
                            {
                                Perm2Comb[count] = Convert.ToSByte(494 - (a & 0x1ff));
                            }
                            break;
                    }
                    if (idx == i)
                    {
                        SymState[count] |= (char)(1 << (s / sym_inc));
                    }
                    Raw2Sym[idx] = (char)((count << 4 | s) / sym_inc);
                }
                Sym2Raw[count++] = (char)i;
            }
            return count;
        }

        internal static void InitFlipSym2Raw()
        {
            InitSym2Raw(2048, FlipS2R, FlipR2S = new char[2048], SymStateFlip, 0);
        }

        internal static void InitTwistSym2Raw()
        {
            InitSym2Raw(2187, TwistS2R, TwistR2S = new char[2187], SymStateTwist, 1);
        }

        internal static void InitPermSym2Raw()
        {
            InitSym2Raw(40320, EPermS2R, EPermR2S = new char[40320], SymStatePerm, 2);
            CubieCube cc = new CubieCube();
            for (int i = 0; i < 2768; i++)
            {
                cc.SetEPerm(EPermS2R[i]);
                cc.InvCubieCube();
                PermInvEdgeSym[i] = (char)cc.getEPermSym();
            }
        }
    }
}
